## 实现边界控制

  ### 核心原则

  **严格遵守优先于变通绕过** - 精确执行需求，遇阻则问。

  ### 禁止行为

  **未经明确批准，严禁**：
  - 遇到困难时自行简化或缩减范围
  - 添加需求中未提及的兜底/防御性逻辑
  - 为未提及的边缘情况添加兼容层
  - 实现未要求的"锦上添花"功能
  - 实现过程中未经询问擅自更换方案

  ### 遇阻处理

  **关键规则**：不要默默绕过问题。

  1. **立即停止**，当：
     - 技术方案未按预期工作
     - 需求看起来不可能或存在冲突
     - 实现需要变更范围
     - 你想添加"以防万一"的代码

  2. **向用户报告**：
     - 遇到的具体问题是什么
     - 原始需求是什么
     - 有哪些可选方案（不要替用户选择）
     - 等待明确指示

  3. **询问，而非假设**：
     ❌ "因为 Y 太复杂，我简化了 X"
     ✅ "我遇到了 Y 问题。可选方案：A、B、C。你倾向哪个？"

     ❌ "为边缘情况 Z 添加了兜底处理"
     ✅ "是否需要处理边缘情况 Z？如果需要，如何处理？"

  ### 范围控制

  **最小可行实现**：
  - 只实现明确要求的内容，不多不少
  - 不做"顺手改进"
  - 不为假设场景预防性处理错误
  - 不为"未来扩展性"添加抽象层

  **自检问题**（写代码前问自己）：
  1. 用户明确要求这个了吗？
  2. 这是满足需求的最简方案吗？
  3. 我是因为卡在真正问题上才加这个的吗？
  4. 删掉这段代码会违反任何明确需求吗？

  ### 需要避免的反模式

  | 反模式 | 示例 | 正确做法 |
  |--------|------|----------|
  | 静默简化 | "由于复杂度问题采用了更简单的方案" | 询问用户偏好哪种复杂度权衡 |
  | 防御性编码 | `if (x != null && x.y != null && ...)` | 只对需求明确要求的情况做防护 |
  | 过度抽象 | 为单一实现创建接口 | 先写具体实现 |
  | 提前规划 | "以防将来需要支持 X" | YAGNI - 真正需要时再实现 |
  | 范围蔓延 | "顺便修复/改进了附近代码" | 单独提交，先询问 |

  ### 沟通协议

  **偏离计划前**：
  🚧 阻塞：[具体问题]
  原始需求：[被要求做什么]
  问题：[为什么当前方案行不通]
  可选方案：
  1. [方案 A] - 代价：...
  2. [方案 B] - 代价：...
  3. [需要更多信息：...]

  等待你的决定。

  **想添加计划外代码时**：
  💡 建议：[想添加什么]
  原因：[为什么觉得需要]
  不加的影响：[没有它会怎样]

  是否加入？[需要明确回复]

  ### 完成定义补充

  在 Definition of Done 中添加：
  - [ ] 没有添加超出明确需求的代码
  - [ ] 没有静默的范围变更或简化
  - [ ] 所有偏离计划的地方都经过用户批准
  - [ ] 没有"以防万一"的兜底逻辑
  - [ ] 实现复杂度与需求复杂度匹配